'''
Use:

sys._sage_.kernel_timeout = float("inf")

ns = InteractiveNamespace(x=10,y=3)
A=slider('x', ns, 0, 2)
A.create()
B=slider('y', ns, 0, 2)
B.create()
C=slider('xy', ns, 0, 2, 'x-y')
C.create()
var('t')
E=pythoncode('x',ns,"""
print x
show(plot(sin(x*t), (t,-3,3),plot_points=3,figsize=2))
print 'hi'
""")
E.create()
D=input('xy',ns,'x')
D.create()

with interact

'''

from uuid import uuid4
import symtable
import re
import tokenize
from keyword import iskeyword
from collections import namedtuple, defaultdict
from itertools import chain

VariableUpdate = namedtuple('VariableUpdate', ['value', 'control'])

controls={}
identifier_regexp = re.compile('^'+tokenize.Name+'$')

def is_identifier(s):
    return (not iskeyword(s)) and (identifier_regexp.match(s) is not None)


def handler_wrapper(msg_type):
    import sys
    def register(f):
        def g(stream, ident, msg):
            return f(msg['content'])
        sys._sage_.register_handler(msg_type, g)
    return register

@handler_wrapper("variable_update")
def update_interact_msg(msg):
    return controls[msg['control_id']].variable_update(msg)

@handler_wrapper("control_update")
def update_interact_msg(msg):
    return controls[msg['control_id']].control_update(msg)

class InteractiveNamespace(dict):
    def __init__(self, *args, **kwargs):
        """
        Set up a namespace id
        """
        dict.__init__(self,*args,**kwargs)
        self.id = 'namespace-'+unicode(uuid4())
        self.__dependencies__ = defaultdict(set)

    def __setitem__(self, key, value):
        """
        Set a value in the dictionary and notify the frontend

        As a convenience, if the value is a VariableUpdate instance,
        the control id is also sent.  This is useful if, for example,
        the control wishes to ignore the update message (by ignoring
        any update messages generated by itself).
        """
        if isinstance(value, VariableUpdate):
            control = value.control
            value = value.value
        else:
            control = None
        dict.__setitem__(self, key, value)
        for c in self.__dependencies__[key]:
            msg = c.control_update({'control': control, 'variable': key})
            sys._sage_.display_message({'text/plain': 'control update',
                                        'application/sage-interact-control-update': {'control': c.id, 'msg': msg}})
        # we don't send the value because it may not be jsonalizable
        #sys._sage_.display_message({'text/plain': 'variable changed',
        #                            'application/sage-interact-variable': {'namespace': self.id,
        #                                                                   'variable': key,
        #                                                                   'control': control}})

    def multiset(self, d, control=None):
        """
        Set multiple variables at a time

        This is a convenience method that sends just one variable
        update message instead of a separate one for each variable.
        If a control updates multiple variables, it should use this
        method to do so.
        """
        for k,v in d.iteritems():
            dict.__setitem__(self, k, v)
        controls = set()
        controls.update(*[self.__dependencies__[k] for k in d])
        for c in controls:
            msg = c.control_update({'control': control, 'variable': d.keys()})
            sys._sage_.display_message({'text/plain': 'control update',
                                        'application/sage-interact-control-update': {'control': c.id, 'msg': msg}})
        # we don't send the value because it may not be jsonalizable
        #sys._sage_.display_message({'text/plain': 'variable changed',
        #                            'application/sage-interact-variable': {'namespace': self.id,
        #                                                                   'variable': d.keys(),
        #                                                                   'control': control}})

    def register(self, control, var):
        """
        Register a control's dependencies

        These controls will get notified when a variable is updated 
        """
        for v in var:
            self.__dependencies__[v].add(control)

__default_namespace__ = None
from contextlib import contextmanager
@contextmanager
def interactive_namespace(ns=None,**kwargs):
    if ns is None:
        ns = InteractiveNamespace(kwargs)
    else:
        ns.update(kwargs)
    global __default_namespace__
    __default_namespace__ = ns
    yield ns
    __default_namespace__ = None
def __get_ns(ns):
    if ns is None:
        global __default_namespace__
        return __default_namespace__
    else:
        return ns

class Control(object):
    def __init__(self, var, namespace=None):
        """
        Initialize the control

        Subclasses should call this function with a list of variables
        (either as a list of strings, or as a single string with
        variables separated by commas or whitespace), and a namespace
        (which may be None, in which case the current active namespace
        will be used).
        """
        self.id = 'control-'+unicode(uuid4())
        global controls
        controls[self.id] = self
        if isinstance(vars, basestring):
            self.var = vars.replace(',',' ').split()
        self.var = var
        if namespace is None:
            global __default_namespace__
            namespace = __default_namespace__
        self.ns = namespace
        self.ns.register(self, self.var)


    def create(self):
        """
        Create a control by sending necessary messages

        Subclasses should use self.send_create_message to send a
        message to the client with the necessary information to create
        a control.  Simple classes will probably just implement this
        as a single call to self.send_message('ControlName').
        """
        pass
    
    def variable_update(self, msg):
        """
        Update variables based on the content of the message.

        Subclasses should override this to receive messages from the
        client control and set the necessary variables in the
        namespace `self.ns`.  Simple controls may implement this as
        just `self.ns[self.var] = msg['value']`.
        """
        pass

    def control_update(self, msg):
        """
        Return the necessary information to update a control.

        Subclasses should override this to *return* a dictionary
        representing a JSON message to be sent to the client control
        with whatever information the client needs to update the
        control.  Usually, this method is called when a variable in
        self.var is updated.
        """
        pass

    def send_create_message(self, control_type, msg = None):
        """
        A utility function to send a message to the client side to create a control.

        This function won't normally be overridden by subclasses.
        """
        if msg is None:
            msg = {}
        msg['control_id'] = self.id
        msg['namespace'] = self.ns.id
        msg['variable'] = [self.var] if isinstance(self.var,basestring) else list(self.var)
        msg['control_type'] = control_type
        sys._sage_.display_message({'text/plain': control_type,
                                    'application/sage-interact-control': msg})

class Widget(object):
    pass

class DiscreteSliderWidget(Widget):
    def __init__(self, values):
        self.values = values
        self.reverse_values = dict((value,i) for i,value in enumerate(values))

    def create_msg(self):
        return {'min': int(0),
               'max': len(self.values)-1}

    def value_to_index(self, value):
        return self.reverse_values[value]
    def index_to_value(self, index):
        return self.values[index]

class ContinuousSliderWidget(Widget):
    def __init__(self, values):
        self.min = values[0]
        self.max = values[1]
        if len(values)==3:
            self.step = values[2]
        else:
            self.step = None
    def create_msg(self):
        msg =  {'min': float(self.min),
               'max': float(self.max)}
        if self.step is not None:
            msg['step'] = float(self.step)
        return msg
    def value_to_index(self, value):
        return float(value)
    def index_to_value(self, index):
        from sage.all import RR
        return RR(index)

class Slider(Control):
    def __init__(self, var, values, ns=None, enabled=True):
        super(Slider, self).__init__(var=var, namespace=ns)
        if isinstance(values, list):
            self.widget = DiscreteSliderWidget(values)
        elif isinstance(values, tuple) and 2<=len(values)<=3:
            self.widget = ContinuousSliderWidget(values)
        self.enabled=enabled

    def create(self):
        msg = {'enabled': self.enabled}
        msg.update(self.widget.create_msg())
        self.send_create_message('Slider', msg)

class ExpressionSlider(Slider):
    def __init__(self, expr, range, ns=None):
        # find the variables in the expression
        global __default_namespace__
        if ns is None:
            ns = __default_namespace__
        var = [v for v in symtable.symtable(expr, '<string>', 'exec').get_identifiers() if v in ns]
        super(ExpressionSlider, self).__init__(var=var, values=range, ns=ns, enabled=False)
        self.code = compile(expr, '<string>', 'eval')

    def control_update(self, msg):
        return {'value': self.widget.value_to_index(eval(self.code, globals(), self.ns))}

class VariableSlider(Slider):
    def __init__(self, var, values, ns=None, enabled=True):
        super(VariableSlider, self).__init__(var, values, ns=ns, enabled=enabled)
    def variable_update(self, msg):
        self.ns[self.var] = VariableUpdate(value=self.widget.index_to_value(msg['value']), control=self.id)
    def control_update(self, msg):
        return {'value': self.widget.value_to_index(self.ns[self.var])}


def slider(var, values, ns=None):
    if is_identifier(var):
        return VariableSlider(var, values, ns=ns)
    else:
        return ExpressionSlider(var, values, ns=ns)

class ExpressionBox(Control):
    def __init__(self, var, ns=None):
        super(ExpressionBox, self).__init__(var=var, namespace=ns)
    def create(self):
        self.send_create_message('ExpressionBox')
    def variable_update(self, msg):
        self.ns[self.var] = sage_eval(msg['value'], locals=self.ns)
    def control_update(self, msg):
        return {'value': repr(self.ns[self.var])}

class Checkbox(Control):
    def __init__(self, var, ns=None):
        super(Checkbox, self).__init__(var=var, namespace=ns)
    def create(self):
        self.send_create_message('Checkbox')
    def variable_update(self, msg):
        self.ns[self.var] = msg['value']
    def control_update(self, msg):
        return {'value': bool(self.ns[self.var])}
        
class PythonCode(Control):
    """
    with interactive_namespace(x=4,y=20):
        print "x="
        slider('x', (0,100)).create()
        print "y="
        slider('y', (0,100)).create()
        PythonCode('print x+y').create()
    """
    def __init__(self, code, ns=None):
        global __default_namespace__
        if ns is None:
            ns = __default_namespace__
        var = [v for v in symtable.symtable(code, '<string>', 'exec').get_identifiers() if v in ns]
        super(PythonCode, self).__init__(var=var, namespace=ns)
        self.code = compile(code, '<string>', 'exec')

    def create(self):
        self.send_create_message('OutputRegion')

    def control_update(self, msg):
        exec(self.code, globals(), self.ns)

class InteractFunction(Control):
    def __init__(self, f):
        ns = InteractiveNamespace()
        import inspect
        argspec = inspect.getargspec(f)
        self.defaults = zip(argspec.args, [None]*(len(argspec.args)-len(argspec.defaults))+list(argspec.defaults))
        ns.update(self.defaults)
        super(InteractFunction, self).__init__(var = ns.keys(), namespace=ns)
        self.fn = f
        self.order = argspec.args
        self.fn.ns = ns
        self.create()

    def create(self):
        # TODO: use the existing automatic rules
        # TODO: lay these out according to whatever layout is specified, or the automatic layout rules
        self.send_create_message('OutputRegion')
        for v in self.order:
            ExpressionBox(v,ns=self.ns).create()
        # output region is an output_region control that depends on all of the function inputs

    def control_update(self, msg):
        # run the function with the appropriate arguments
        self.fn(**self.ns)

"""
Point2d:
http://aleph.sagemath.org/?z=eJytV01v4zYQPce_gmukELVQZMdpD3XWBbLJHrZAi0WxPaWBoUi0zY1MCiKVRDX83_tGH5RkZzc5VAdbIoczj28eh6QpTbg00VoswweRK5EurdwKXVi2YKtUR5aPpVqN_RHeE-5trM3MfDLJo6dwLe2muA9jvZ18i4xW6xzDJuQrFmk6kcqKPIrt2VYYajSTWCuby3vX416WKoJRFsUizErPH9ETp5Ex7IuGzeyGX9NQnfrzEcOTiBVbLqWSdrnkRqSrgD1G-XmAn1nAlGnM6DFFJnLeuAkYGfuhG-t3dugIyQnmTX9HHbO6YzbsUAbNyjhUcS4iKypMfRAdyYk0WRqVy4YUvvOseLYTtEnlzZk3u6nn7AVu9I8eL8qyVMaRlVpV1J852uOaMjjdec37Uib4rIDL5G0BXkfQ-rZlJmgGWcV18sYJvO4fpMvoPiXfty5LQZeXu_8rkBNhy5EyoGm_9112WyjLIkvaNAdsa9b9XDcjt0VqpRGW7xzoOZne0oTOvbveDLr2mXe3D1jD6KJJVBe_pfoH4XNhi1wh5VUUN5GOOQSuIx33ze72o43dpjwfj8ejDybOZWZ_G6GHxQI6b5d2WFiZhrXUP6ViK5S9HI0mkwrA3yoRuYl1LsJvhp2HP4cXbRcVD9SOwll8M6HO1203j302m05_PZtNz2fsd5GLbcmuzOZBqMgE7EbHBYW6TnWRsM8qDo9Dsm1UsnvBVrkQacmw2KjgFFYkrIrK7EawPz5_ZVgzQhlRufirosywiK0KFdNKCmAX2YA9bYRiUj3qB5HgS6Yp0yqtIsDveg2ICYss22pj0RMLpAEOkyKXag1_a_kIB09SJfqJ6RWj0hrChhi1m1xbmxKvbVhOL4gTSeuzXZXSintkHTUiYFG-Bg9NfQ6QagONXTq7LBePUhdUkaZda4ok5f0grWvWH6DEE7uB5WXT1W0CqkjTtrWO2DgLqfSUfIDOry339V-jxRciEzAFTo4DUw8Sj2pIFC4qMtgZ42R95hD7rXkTHYZ2I03bSlDQhL9KMa5drhjvnH8ATx0k-EpFlH-tJ84bAlyg71EyZFE_XfZW4tvIAl1MpEZU6N61cXu4usAoJy2-Kq1BR1XnzOWqIr8vkiot-Kket5g_NxtGs8WasNks-wv-yOaggSP8qw7DDIrXtE00taOnSsZR0aKA3ac6fsA21dc_rcVBguktJCox9UrbVYPBjgpPIdjJQFAs-DiRj-OA7WQyZ-Q-7LbBvd-L9ZLXMDaG7zZCrjcWm9r5dJo9e1QDErvpfd_rHGWFGrJnZnQqE7iN4gd0ZVGSIDHo-wWm-8MowAHkpw6n75NGhEq-aj6E8sLII3QH4F7DtoX-pELXtAcNvmElwlSv-e0QQtAPHgyh1Ci4f-d3RafeoPpVR6ASQveFpMye4Knlzqp27AISeKL0E33Bohbv5b62JAG49BpQ5E5P3sGOjKlVQ2gUY7su30cCqE-McwAKM20kYQxTsbJVO3ZkJPis32d1th86H9dCG8_ZKSn7ueQDnJtIJcBVGwWDOfjEeO2lXa8DRpM8Wq9pVnzHmhRQGZsfSBQHhSI3mjK81Y809_r7CpY74MUkApoS_veBi0fO52734TVvAc3Xf-EgZSo_tVHjgsDv31A_esv9SA6o5-1hK3CnKnfweW39k3L6hMGevVssDoafDKrCUDbDgxSYG0jlwDduFC3YOXsB99y91TSffEccPTRH4uj6_EZlmOd4CHOZC-whcOkWVbWd0LLaChuRwN3i6va7xiY0NrK0SYEnTz94reVJJT5oc1BZPNINTojt4HoXaU7eHjTh1SvkuH_WaLuFsG8_9m2Z2UM9TjzuBtiEN7fu_nD3ww2oEdnl6MOkPafi0BoSRUgO9069wPvn1PPpMlld0loPOJL92eaQPy_Op0G5uPBHGY5slnnP3uhqYVAqcWn0qIgqnLim9fIYXTX7Fq6NrX3pjT46-_LA_mPP_hoQ2sssOSZjXFRH1z0b0Mc9i_uvWdABvIW0-Ak-S_x6P_HnoATWVFv-_N5Ixcv3FoLhNji7CC78YCXXRv4rFhcB2SwrKg2-II6MZg4JUY2AdjDn0Gz0E-JSrJvFl9JutLrWCe4VFbKbDtl_aK31JQ==&lang=sage
"""




"""
sys._sage_.kernel_timeout = 100
load('/Users/grout/projects/sagenb/sagecell/contrib/interact/interact_namespace.py')

@InteractFunction
def f(x=1,y=2):
    print x,y
    from time import sleep
    sleep(1)
    if f.ns['y']>10: return
    print 'changing y'
    f.ns['y'] = f.ns['x']+f.ns['y']
    print 'changing x'
    f.ns['x'] = f.ns['x']+1
    sleep(1)

What I think should happen:

1. output region created, expression boxes created
2. function executed once
3. change notification sent out for y.  the expressionbox for y queued up, the output region queued up
4. f continues to execute, sends out change notification for x, the expressionbox for x and the output region queued up again
5. then the expressionbox for y is processed, changes y
6. then the output region executed (from y's change), which actually picks up x's change.
7. the output regio
 

Okay, *HUGE* problem: controls are not updated immediately, so controls have to wait until the python code is executed in order to ask for their values.

* Solution 1: have a separate thread that is used to inquire about control values
* Solution 2: send the new control values instead of just an update message



"""
